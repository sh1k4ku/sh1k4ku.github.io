<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sh1k4ku&#39;s blog</title>
  
  <subtitle>记录我的学习之路</subtitle>
  <link href="http://sh1k4ku.github.io/atom.xml" rel="self"/>
  
  <link href="http://sh1k4ku.github.io/"/>
  <updated>2021-08-19T14:34:18.139Z</updated>
  <id>http://sh1k4ku.github.io/</id>
  
  <author>
    <name>sh1k4ku</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>吃瓜杯</title>
    <link href="http://sh1k4ku.github.io/2021/08/19/%E5%90%83%E7%93%9C%E6%9D%AF/"/>
    <id>http://sh1k4ku.github.io/2021/08/19/%E5%90%83%E7%93%9C%E6%9D%AF/</id>
    <published>2021-08-19T12:46:11.000Z</published>
    <updated>2021-08-19T14:34:18.139Z</updated>
    
    <content type="html"><![CDATA[<p>做了下闪电五连鞭，题出的很有意思，春哥从国外比赛扒的题（<a href="https://github.com/BCACTF/bcactf-2.0">BCACTF</a>）,难度不大，结合了RSA和相似矩阵</p><span id="more"></span><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">朋友们好。</span><br><span class="line"></span><br><span class="line">今天，和大家，探讨一下，怎样打RSA置换闪电鞭。</span><br><span class="line"></span><br><span class="line">要做到三点。</span><br><span class="line"></span><br><span class="line">一：要做到问题真正的放松。但是线性代数基本知识要用好。这里面，该松的松，该紧的紧。松中有紧，紧中有松。这个问题非常复杂，在这里不多说。在问题的描述中有详细的解释；</span><br><span class="line"></span><br><span class="line">二：要练好内功，你才能代码中发力，打出RSA置换劲儿。慢练，这是签到的……快练！下合上开，上合下开！所以，这个RSA置换劲儿啊……这个RSA和置换都在动啊……</span><br><span class="line"></span><br><span class="line">三：要用高维的RSA置换劲儿，才能打出RSA置换闪电鞭。因为这个鞭的劲儿，你看……是不是，你看……都是高维的啊……</span><br><span class="line"></span><br><span class="line">下面我打一个连五鞭啊……打了五鞭：一鞭，两鞭，三鞭，四鞭，五鞭。这五鞭要连次打，你看：实战时间，一定要动武，全身松好，用高维的劲，RSA置换劲儿！才能打出<span class="built_in">flag</span>，打出RSA置换闪电鞭！</span><br><span class="line"></span><br><span class="line">谢谢朋友们。</span><br></pre></td></tr></table></figure></blockquote><h1 id="1bian"><a href="#1bian" class="headerlink" title="1bian"></a>1bian</h1><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">n = 8870619487339789349033932217513908953609539651949986489986889710933094577873155191810742828503059670650154455297603719</span><br><span class="line">e = 3</span><br><span class="line"></span><br><span class="line">with open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    m = bytes_to_long(f.read())</span><br><span class="line"></span><br><span class="line">assert n &gt; m</span><br><span class="line"></span><br><span class="line">Zn = Zmod(n)</span><br><span class="line">P = PermutationGroupElement(&#x27;(1,6)(2,3,5)(4,7)&#x27;)</span><br><span class="line">P = Matrix(Zn, P.matrix())</span><br><span class="line"></span><br><span class="line">def encrypt(m):</span><br><span class="line">    C = (m * P) ^ e</span><br><span class="line">    return C.list()</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">[0, 0, 0, 0, 0, 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231, 0, 0, 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231, 0, 0, 0, 0, 0, 0, 0, 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231, 0, 0, 0, 0, 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231, 0, 0, 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231, 0, 0, 0]</script><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>题目生成了一个置换群和对应的矩阵P，加密算法为</p><script type="math/tex; mode=display">C=(mP)^e=m^eP^e\\P^3同样是个置换矩阵，并且元素全为1。所以C中的元素即为c=m^3</script><p>又由于n易分解，所以就就化为了最简单的RSA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c=<span class="number">6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231</span></span><br><span class="line">n = <span class="number">8870619487339789349033932217513908953609539651949986489986889710933094577873155191810742828503059670650154455297603719</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">a=[<span class="number">35200554341</span> , <span class="number">35592761021</span> , <span class="number">48105446183</span> , <span class="number">48479007809</span> , <span class="number">50240938337</span> , <span class="number">50769514811</span> , <span class="number">62183036099</span> , <span class="number">63345654131</span> , <span class="number">66104249843</span> , <span class="number">67515121673</span> , <span class="number">67704082961</span>]</span><br><span class="line">p=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">   p*=i-<span class="number">1</span></span><br><span class="line">d=gmpy2.invert(e,p)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"><span class="comment">#ctfshow&#123;W4r_Dull_Eeeee_LLL3333_A_n0_F14sH_@w@&#125;</span></span><br></pre></td></tr></table></figure><h1 id="2bian"><a href="#2bian" class="headerlink" title="2bian"></a>2bian</h1><h1 id="题-1"><a href="#题-1" class="headerlink" title="题"></a>题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">0x36D</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">3950848271664122675439855009329233027357977239695163232943132810210035583520735079984423511153607529820284200137188647</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    m = bytes_to_long(f.read())</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> n &gt; m</span><br><span class="line"></span><br><span class="line">Zn = Zmod(n)</span><br><span class="line">P = PermutationGroupElement(<span class="string">&#x27;(1,14,25,8,23,15)(2,22,17)(3,18,13,33,11,30,26,27,10,6,16,31,28,21,29,36,7,9)(4,35,12,32,20,5,24)(19,34)&#x27;</span>)</span><br><span class="line">P = Matrix(Zn, P.matrix())</span><br><span class="line">A = Matrix(Zn, <span class="number">36</span>, <span class="number">36</span>, <span class="keyword">lambda</span> x, y: random.randint(<span class="number">0</span>, <span class="number">0x36D</span>))</span><br><span class="line">B = A * P * A^-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">m</span>):</span></span><br><span class="line">    C = (m * B) ^ e</span><br><span class="line">    <span class="keyword">return</span> C.<span class="built_in">list</span>()</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">A是一个随机矩阵，但随机数种子是确定的，所以A是确定的\\所以B=APA^{-1}也是确定的\\加密算法C=(mB)^e=m^eB^e\\那么CB^{-3}的元素即为m^3\\然后就化到了第一问上</script><h2 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">import</span> random</span><br><span class="line"><span class="attribute">from</span> Crypto.Util.number import *</span><br><span class="line"><span class="attribute">random</span>.seed(<span class="number">0</span>x<span class="number">36</span>D)</span><br><span class="line"></span><br><span class="line"><span class="attribute">n</span> = <span class="number">3950848271664122675439855009329233027357977239695163232943132810210035583520735079984423511153607529820284200137188647</span></span><br><span class="line"><span class="attribute">e</span>=<span class="number">3</span></span><br><span class="line"><span class="attribute">Zn</span> = Zmod(n)</span><br><span class="line"><span class="attribute">P</span> = PermutationGroupElement(&#x27;(<span class="number">1</span>,<span class="number">14</span>,<span class="number">25</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">15</span>)(<span class="number">2</span>,<span class="number">22</span>,<span class="number">17</span>)(<span class="number">3</span>,<span class="number">18</span>,<span class="number">13</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">30</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">16</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">21</span>,<span class="number">29</span>,<span class="number">36</span>,<span class="number">7</span>,<span class="number">9</span>)(<span class="number">4</span>,<span class="number">35</span>,<span class="number">12</span>,<span class="number">32</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">24</span>)(<span class="number">19</span>,<span class="number">34</span>)&#x27;)</span><br><span class="line"><span class="attribute">P</span> = Matrix(Zn, P.matrix())</span><br><span class="line"><span class="attribute">A</span> = Matrix(Zn, <span class="number">36</span>, <span class="number">36</span>, lambda x, y: random.randint(<span class="number">0</span>, <span class="number">0</span>x<span class="number">36</span>D))</span><br><span class="line"><span class="attribute">B</span> = A * P * A^-<span class="number">1</span></span><br><span class="line"><span class="attribute">C</span>#C太太太大了，不丢了</span><br><span class="line"><span class="attribute">c</span>=<span class="number">788338113035295195878123865420815134674503086857319693837443675089195439938279689750424184012172121716196117254817680</span></span><br><span class="line"><span class="attribute">phi</span>=euler_phi(n)</span><br><span class="line"></span><br><span class="line"><span class="attribute">d</span>=inverse_mod(e,phi)</span><br><span class="line"><span class="attribute">print</span>((C*B^-<span class="number">3</span>).trace())</span><br><span class="line"><span class="attribute">print</span>(long_to_bytes(pow(c,d,n)))</span><br></pre></td></tr></table></figure><h1 id="3bian"><a href="#3bian" class="headerlink" title="3bian"></a>3bian</h1><p>之后都变成了nc题，并且能给我条件是矩阵的迹</p><h2 id="题-2"><a href="#题-2" class="headerlink" title="题"></a>题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">0x36D</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">25126409997644048715497037905442671105116158875704245711785280791201683049008805107543997350200944348915833337286069203</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    m = bytes_to_long(f.read())</span><br><span class="line"><span class="keyword">assert</span> n &gt; m</span><br><span class="line"></span><br><span class="line">Zn = Zmod(n)</span><br><span class="line">P = PermutationGroupElement(<span class="string">&#x27;(1,3,6,29,25,34,22,33,10,16,7)(2,21,19,17,31,9,5,30,27,35,32,11)(4,20,28,23,18,15)(8,26,14,12)(36,24,13)&#x27;</span>)</span><br><span class="line">P = Matrix(Zn, P.matrix())</span><br><span class="line">A = Matrix(Zn, <span class="number">36</span>, <span class="number">36</span>, <span class="keyword">lambda</span> x, y: random.randint(<span class="number">0</span>, <span class="number">0x36D</span>))</span><br><span class="line">B = A * P * A^-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">m</span>):</span></span><br><span class="line">    C = (m * B) ^ e</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"></span><br><span class="line">matrix_map = &#123;<span class="string">&quot;I&quot;</span>: Matrix(Zn, matrix.identity(<span class="number">36</span>)), <span class="string">&quot;B&quot;</span>: B, <span class="string">&quot;C&quot;</span>: encrypt(m)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_add</span>(<span class="params">matrix_map</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第一个矩阵：&quot;</span>)</span><br><span class="line">    A = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第二个矩阵：&quot;</span>)</span><br><span class="line">    B = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    C = matrix_map[A]+matrix_map[B]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;这两个矩阵之和的迹是：<span class="subst">&#123;C.trace()&#125;</span>，迹你实在是太美~&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_product</span>(<span class="params">matrix_map</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第一个矩阵：&quot;</span>)</span><br><span class="line">    A = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第二个矩阵：&quot;</span>)</span><br><span class="line">    B = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    C = matrix_map[A]*matrix_map[B]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;这两个矩阵之积的迹是：<span class="subst">&#123;C.trace()&#125;</span>，迹你实在是太美~&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_kproduct</span>(<span class="params">matrix_map</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;矩阵：&quot;</span>)</span><br><span class="line">    A = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;乘数：&quot;</span>)</span><br><span class="line">    k = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    k = <span class="built_in">int</span>(k)</span><br><span class="line">    B = k * matrix_map[A]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;数乘结果的迹是：<span class="subst">&#123;B.trace()&#125;</span>，迹你实在是太美~&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_power</span>(<span class="params">matrix_map</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;矩阵：&quot;</span>)</span><br><span class="line">    A = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;幂次：&quot;</span>)</span><br><span class="line">    k = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">    k = <span class="built_in">int</span>(k)</span><br><span class="line">    B = matrix_map[A] ^ k</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;求幂结果的迹是：<span class="subst">&#123;B.trace()&#125;</span>，迹你实在是太美~&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_save</span>(<span class="params">A, matrix_map</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;存个小档？ (Y/N)&quot;</span>)</span><br><span class="line">    s = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip().upper()</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;运算结果叫啥名呢？&quot;</span>)</span><br><span class="line">        S = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip()</span><br><span class="line">        matrix_map[S] = A</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;存上档咯！&quot;</span>)</span><br><span class="line"></span><br><span class="line">WELCOME = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">欢迎来打第三鞭！</span></span><br><span class="line"><span class="string">在这一鞭中，你可以尝试打出两个矩阵的和，积。</span></span><br><span class="line"><span class="string">或者一个矩阵的数乘，幂次。</span></span><br><span class="line"><span class="string">但是由于av50183113，所以我只会告诉你运算结果的迹，因为迹你太美。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">MENU = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">请开始你的表演：</span></span><br><span class="line"><span class="string">[S] 打印矩阵</span></span><br><span class="line"><span class="string">[+] 两矩阵相加</span></span><br><span class="line"><span class="string">[*] 两矩阵相乘</span></span><br><span class="line"><span class="string">[K] 一矩阵数乘</span></span><br><span class="line"><span class="string">[^] 一矩阵求幂</span></span><br><span class="line"><span class="string">[Q] 886</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(WELCOME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(MENU)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opt = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>).strip().upper()</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&quot;S&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;迹你太美……baby……迹你实在是太美……&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> matrix_map.items():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;v.trace()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> (opt == <span class="string">&quot;+&quot;</span>):</span><br><span class="line">            M = server_add(matrix_map)</span><br><span class="line">            server_save(M, matrix_map)</span><br><span class="line">        <span class="keyword">elif</span> (opt == <span class="string">&quot;*&quot;</span>):</span><br><span class="line">            M = server_product(matrix_map)</span><br><span class="line">            server_save(M, matrix_map)</span><br><span class="line">        <span class="keyword">elif</span> (opt == <span class="string">&quot;K&quot;</span>):</span><br><span class="line">            M = server_kproduct(matrix_map)</span><br><span class="line">            server_save(M, matrix_map)</span><br><span class="line">        <span class="keyword">elif</span> (opt == <span class="string">&quot;^&quot;</span>):</span><br><span class="line">            M = server_power(matrix_map)</span><br><span class="line">            server_save(M, matrix_map)</span><br><span class="line">        <span class="keyword">elif</span> (opt == <span class="string">&quot;Q&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;再见！&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;李在……赣神魔？&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这波和闪电鞭配合得不是很好……&quot;</span>)</span><br></pre></td></tr></table></figure><p>端口那边初始储存了三个矩阵，B、C和I，I即单位矩阵，能够进行矩阵相加、相乘、数乘、求幂、展示的操作并且给出的是结果矩阵的迹，也就是对角线上元素的和</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做了下闪电五连鞭，题出的很有意思，春哥从国外比赛扒的题（&lt;a href=&quot;https://github.com/BCACTF/bcactf-2.0&quot;&gt;BCACTF&lt;/a&gt;）,难度不大，结合了RSA和相似矩阵&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://sh1k4ku.github.io/categories/CTF/"/>
    
    
    <category term="RSA" scheme="http://sh1k4ku.github.io/tags/RSA/"/>
    
    <category term="matrix" scheme="http://sh1k4ku.github.io/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>做题随记</title>
    <link href="http://sh1k4ku.github.io/2021/08/11/2021-8-11-%E5%81%9A%E9%A2%98%E9%9A%8F%E8%AE%B0/"/>
    <id>http://sh1k4ku.github.io/2021/08/11/2021-8-11-%E5%81%9A%E9%A2%98%E9%9A%8F%E8%AE%B0/</id>
    <published>2021-08-11T10:00:00.000Z</published>
    <updated>2021-08-18T07:41:34.761Z</updated>
    
    <content type="html"><![CDATA[<p>一道浮点位数很高的题目。。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line">getcontext().prec = <span class="number">300</span> <span class="comment">#给定精确度为300位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pi</span>():</span><span class="comment">#生成三百位数的pi,小数点后299位</span></span><br><span class="line">    lasts, t, s, n, na, d, da = <span class="number">0</span>, Decimal(<span class="number">3</span>), <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span></span><br><span class="line">    <span class="keyword">while</span> s != lasts:</span><br><span class="line">        lasts = s</span><br><span class="line">        n, na = n + na, na + <span class="number">8</span></span><br><span class="line">        d, da = d + da, da + <span class="number">32</span></span><br><span class="line">        t = (t * n) / d</span><br><span class="line">        s += t</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sin</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = Decimal(x) % pi()</span><br><span class="line">    p, factor = <span class="number">0</span>, x</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):<span class="comment">#sinx的泰勒展开</span></span><br><span class="line">        p += factor</span><br><span class="line">        factor *= - (x ** <span class="number">2</span>) / ((<span class="number">2</span> * n + <span class="number">2</span>) * (<span class="number">2</span> * n + <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">int</span>.from_bytes(<span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read(), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span>(flag &lt; <span class="number">2</span> ** <span class="number">500</span>)</span><br><span class="line"><span class="built_in">print</span>(sin(flag))</span><br><span class="line"><span class="comment"># 0.0244671923862258387777329311304061726117292338164472101939417405767980930400528701470775326212479053586551379126483335032568358369085951301715103743247208229702075426052832758137520953914256336461357368653604728080035204833015365117280775229337006339154544638317547072102876405128588259546493517773166</span></span><br><span class="line"><span class="comment">#实际上这个结果是小数点后301位。。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>pi()函数用一个不知道是什么的算法生成了300位（小数点后299位）的Π，sin(x)函数用泰勒展开到第9999轮来计算sinx的结果（反正对300位的结果来说绰绰有余了），然后给出了sin(flag)的结果，是小数点后301位的。之前强网杯的ezmath也是用高精度的浮点数，并且也用了e^x的泰勒展开。</p><h1 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h1><p>既然加密是用sinx的泰勒展开，最初想到用arcsin的展开式去求回去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">__import__</span>(<span class="string">&quot;functools&quot;</span>).reduce(<span class="keyword">lambda</span> x, y: x * y, <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arcsin</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = Decimal(x) % pi()</span><br><span class="line">    p = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3000</span>):</span><br><span class="line">        f=x</span><br><span class="line">        p+=double_factorial(<span class="number">2</span>*i-<span class="number">1</span>)*(f**(<span class="number">2</span>*i+<span class="number">1</span>))/((<span class="number">2</span>*i+<span class="number">1</span>)*double_factorial(<span class="number">2</span>*i))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"><span class="comment">#0.0244696342317182955380167878859997878648849860507225686198324843880327826384968171815366236530238829279631100698854243103679784022302933149263781311340548493687767140548481414565508236688055024007324091848224931595200235667864586900877342501435623376419548532684797634337279346936509642695145952284863</span></span><br></pre></td></tr></table></figure><p>这个结果sin还原回去最后一位和结果不同，猜一位就能得到正确的余数</p><h1 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h1><p>牛顿法也能求根，吴师傅爆了3个小时才爆出来。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">getcontext().prec = <span class="number">300</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sin</span>(<span class="params">x</span>):</span></span><br><span class="line">    p, factor = <span class="number">0</span>, x</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):  <span class="comment"># 感觉像泰勒</span></span><br><span class="line">        p += factor</span><br><span class="line">        factor *= - (x ** <span class="number">2</span>) / ((<span class="number">2</span> * n + <span class="number">2</span>) * (<span class="number">2</span> * n + <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = Decimal(<span class="number">0</span>)</span><br><span class="line">r = Decimal(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">des = Decimal(</span><br><span class="line">    <span class="string">&#x27;0.0244671923862258387777329311304061726117292338164472101939417405767980930400528701470775326212479053586551379126&#x27;</span></span><br><span class="line">    <span class="string">&#x27;483335032568358369085951301715103743247208229702075426052832758137520953914256336461357368653604728080035204833015&#x27;</span></span><br><span class="line">    <span class="string">&#x27;365117280775229337006339154544638317547072102876405128588259546493517773166&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    mid2 = (l + r) / <span class="number">2</span></span><br><span class="line">    mid1 = (l + mid2) / <span class="number">2</span></span><br><span class="line">    mid3 = (mid2 + r) / <span class="number">2</span></span><br><span class="line">    p = multiprocessing.Pool(<span class="number">3</span>)</span><br><span class="line">    res = [p.apply_async(sin, args=(mid1,)), p.apply_async(sin, args=(mid2,)), p.apply_async(sin, args=(mid3,))]</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    values = [i.get() <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line">    <span class="keyword">if</span> des &lt; values[<span class="number">0</span>]:</span><br><span class="line">        r = mid1</span><br><span class="line">    <span class="keyword">elif</span> values[<span class="number">0</span>] &lt; des &lt; values[<span class="number">1</span>]:</span><br><span class="line">        l = mid1</span><br><span class="line">        r = mid2</span><br><span class="line">    <span class="keyword">elif</span> values[<span class="number">1</span>] &lt; des &lt; values[<span class="number">2</span>]:</span><br><span class="line">        l = mid2</span><br><span class="line">        r = mid3</span><br><span class="line">    <span class="keyword">elif</span> values[<span class="number">2</span>] &lt; des:</span><br><span class="line">        l = mid3</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;l=&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;r=&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sin(x)=&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(values[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">print</span>(mid1)</span><br><span class="line"><span class="built_in">print</span>(mid2)</span><br><span class="line"><span class="built_in">print</span>(mid3)</span><br><span class="line"><span class="built_in">print</span>(values[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(values[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(values[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#0.0244696342317182955380167878859997878648849860507225686198324843880327826384968171815366236530238829279631100698854243103679784022302933149263781311340548493687767140548481414565508236688055024007324091848224931595200235667864586900877342501435623376419548532684797634337279346936509642695145952284864</span></span><br></pre></td></tr></table></figure><p>这个值用sin反展开回去和结果是一样的，nice，所以现在得到了flag和pi求余的结果了。</p><p>接下来是怎么求flag：</p><script type="math/tex; mode=display">∵n\%pi=x\\∴n=x+m*pi</script><p>因为n是整数，所以可以爆破，但是flag的范围太大了，感觉不太现实。</p><p>还有一个想法：利用n是整数这一点，x和pi都有小数部分，可以转换成同余方程：</p><script type="math/tex; mode=display">例如当精度是2的时候，3.14*m+0.02=n位整数\\∴14*m\%100=98...类推到300位也是如此</script><p>但是最后算出来的m大小远超2**500，所以没能做出来。</p><p>对于这一题还有个疑问，题目给的结果小数点后有301位的，但是pi小数点后只有299位，这样用原始的pi是不可能出解的（试过将pi也增加到301位，但也没出）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道浮点位数很高的题目。。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://sh1k4ku.github.io/categories/CTF/"/>
    
    
    <category term="Crypto" scheme="http://sh1k4ku.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>一……二……开门！</title>
    <link href="http://sh1k4ku.github.io/2021/07/28/%E4%B8%80%E2%80%A6%E2%80%A6%E4%BA%8C%E2%80%A6%E2%80%A6%E5%BC%80%E9%97%A8%EF%BC%81/"/>
    <id>http://sh1k4ku.github.io/2021/07/28/%E4%B8%80%E2%80%A6%E2%80%A6%E4%BA%8C%E2%80%A6%E2%80%A6%E5%BC%80%E9%97%A8%EF%BC%81/</id>
    <published>2021-07-28T08:37:40.000Z</published>
    <updated>2021-08-16T09:29:28.860Z</updated>
    
    <content type="html"><![CDATA[<p>CTFshow上的新题，搞了一天</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> door_sum <span class="keyword">import</span> door_sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># door_sum(l, d, n): calculate the sum of an arithmetic sequence</span></span><br><span class="line"><span class="comment"># with `l` being the first number, `d` being the common difference,</span></span><br><span class="line"><span class="comment"># and `n` being the number of terms</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sanity check:</span></span><br><span class="line"><span class="keyword">assert</span> door_sum(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>) == <span class="number">5050</span></span><br><span class="line"></span><br><span class="line">WELCOME = <span class="string">&#x27;&#x27;&#x27;HELLO!</span></span><br><span class="line"><span class="string">Open the door, and I&#x27;ll show you my flag!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span>(WELCOME)</span><br><span class="line">n_1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;n_1 = &#x27;</span>))</span><br><span class="line">n_2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;n_2 = &#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> (n_1 &gt; <span class="number">2</span> ** <span class="number">0x1337</span> <span class="keyword">and</span> n_2 &gt; <span class="number">2</span> ** <span class="number">0x1337</span> <span class="keyword">and</span> door_sum(<span class="number">1</span>, <span class="number">1</span>, n_1) == <span class="number">0x1337</span> * door_sum(<span class="number">1</span>, <span class="number">2</span>, n_2)):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;OKOK! YOU GOT THE FLAG:&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Uh-Oh, the door is not opened...&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;NONONO!&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>door_sum可以写成等差数列的和</p><p>注意door_sum里的n是项数！！！</p><p>题目的要求是两个数均大于2**4919并且第一个数的数列和是第二个数列和的4919倍</p><script type="math/tex; mode=display">x_n=x_1+d(n-1)\\ S_n=\frac{x_1+x_n}{2}n=(\frac{d(n-1)+2x_1}{2})n=\frac{d(n^2-n)+2x_1n}{2}\\则S_{n1}=\frac{d_1(n_1^2-n_1)+2x_1n_1}{2}\\S_{n2}=\frac{d_2(n_2^2-n_2)+2x_1n_2}{2}\\已知S_{n1}=4919*S_{n2},且d_1=1,d_2=2,x_1=1\\则\frac{n_1^2+n_1}{2}=4919n_2^2\\ \sqrt{\frac{n_1^2+n_1}{9838}}=n2</script><p>走到这里发现走不通了，毕竟是要爆破的，对于这个数量级依旧很难出解。因为要加快爆破速度，了解到佩尔方程：</p><h2 id="佩尔方程"><a href="#佩尔方程" class="headerlink" title="佩尔方程"></a>佩尔方程</h2><script type="math/tex; mode=display">定义：形如x^2 − d y^2=1(d>1,且d不是完全平方数)\\要求第一类佩尔方程的解都是正整数解,也即( x , y ) , x > 0 , y > 0</script><p>显然方程有无数组解，如何求最小解？</p><script type="math/tex; mode=display">把方程化为x=\sqrt{1+dy^2}\\从y=1开始枚举，如果\sqrt{1+dy^2}是整数，那么此时(x,y)就是最小整数解(x_1,y_1)</script><p>如何得到所有的解？</p><p>迭代公式：</p><script type="math/tex; mode=display">x_n=x_{n-1}x_1+dy_{n-1}y_1\\y_n=x_{n-1}y_1+y_{n-1}x_1</script><p>但如果用这个公式求解，时间复杂度依旧是O(n)，当n很大时还是跑不出来，所以使用矩阵快速幂，以O(logn)的时间复杂度求解：</p><script type="math/tex; mode=display">\left[ \begin{matrix} x_n\\ y_n \end{matrix}  \right] \tag{2}=   \left[ \begin{matrix} x_1&d*y_1\\ y_1&x_1 \end{matrix}  \right]^{n-1}    \left[ \begin{matrix} x_1\\ y_1 \end{matrix}  \right]</script><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>改变一下推法：</p><script type="math/tex; mode=display">\frac{n_1^2+n_1}{2}=4919n_2^2\\(n_1+\frac{1}{2})^2-\frac{1}{2}=9838n_2^2\\(2n_1+1)^2-4*9838n_2^2=1</script><p>得到了佩尔方程的表达式，之后使用连分数的性质计算得到了最小解：</p><script type="math/tex; mode=display">(x_1,y_1)=\\(2662019309411216232806345449321879270495478346383, 26838472360889124413883226557207387537524821524)</script><p>可以看到还是很小的（比起2^0x1337)</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_mini_solution</span>(<span class="params">d</span>):</span></span><br><span class="line">    m=<span class="built_in">int</span>(d**<span class="number">0.5</span>)</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    a=[]</span><br><span class="line">    a.append(m)</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    b=m</span><br><span class="line">    c=<span class="number">1</span></span><br><span class="line">    sq=d**<span class="number">0.5</span></span><br><span class="line">    <span class="keyword">while</span>(a[i-<span class="number">1</span>]!=<span class="number">2</span>*a[<span class="number">0</span>]):</span><br><span class="line">        c=(d-b*b)/c</span><br><span class="line">        tmp=(sq+b)/c</span><br><span class="line">        a.append(<span class="built_in">int</span>(tmp))</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        b=a[i-<span class="number">1</span>]*c-b</span><br><span class="line">    <span class="keyword">del</span> a[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    p=[m]</span><br><span class="line">    q=[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(a)):</span><br><span class="line">        <span class="keyword">if</span> j==<span class="number">1</span>:</span><br><span class="line">            p.append(a[j]*p[<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line">            q.append(a[j]*q[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.append(a[j]*p[j-<span class="number">1</span>]+p[j-<span class="number">2</span>])</span><br><span class="line">            q.append(a[j]*q[j-<span class="number">1</span>]+q[j-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p[-<span class="number">1</span>],q[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>*p[-<span class="number">1</span>]**<span class="number">2</span>,<span class="number">2</span>*p[-<span class="number">1</span>]*q[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mulMatrix</span>(<span class="params">x,y</span>):</span>     <span class="comment">#二阶矩阵乘法</span></span><br><span class="line">    ans = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                ans[i][j] += x[i][k] * y[k][j]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickMatrix</span>(<span class="params">m,n</span>):</span></span><br><span class="line">    E = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]        <span class="comment">#先定义一个单位矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        E[i][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n):</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            E = mulMatrix(E,m)</span><br><span class="line">        m = mulMatrix(m,m)</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> E</span><br><span class="line"></span><br><span class="line">d=<span class="number">9838</span>*<span class="number">4</span></span><br><span class="line">x1,y1=find_mini_solution(d)</span><br><span class="line"><span class="built_in">print</span>((x1,y1))</span><br><span class="line">basis_matrix=[[x1,d*y1],[y1,x1]]</span><br><span class="line"></span><br><span class="line">cnt=<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    tmp=quickMatrix(basis_matrix,cnt)</span><br><span class="line">    xn=tmp[<span class="number">0</span>][<span class="number">0</span>]*x1+tmp[<span class="number">0</span>][<span class="number">1</span>]*y1</span><br><span class="line">    yn=tmp[<span class="number">1</span>][<span class="number">0</span>]*x1+tmp[<span class="number">1</span>][<span class="number">1</span>]*y1</span><br><span class="line">    <span class="keyword">if</span> xn &gt;<span class="number">2</span> ** <span class="number">0x1337</span> <span class="keyword">and</span> yn &gt; <span class="number">2</span> ** <span class="number">0x1337</span> <span class="keyword">and</span> xn**<span class="number">2</span>-d*yn**<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(cnt)</span><br><span class="line">        <span class="built_in">print</span>((xn-<span class="number">1</span>)//<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(yn)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cnt+=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>感觉用sage会方便很多0.0</p><p>sage果然方便，连分数有内置的函数，补上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def solve_pell(N, numTry = 100):</span><br><span class="line">cf= continued_fraction(sqrt(N))</span><br><span class="line">for i in range(numTry):</span><br><span class="line">denom = cf.denominator(i)</span><br><span class="line">numer = cf.numerator(i)</span><br><span class="line">if numer^2-N*denom^2 == 1:</span><br><span class="line">return numer,denom</span><br><span class="line">print(solve_pell(9838)) </span><br><span class="line">#(2662019309411216232806345449321879270495478346383, 26838472360889124413883226557207387537524821524)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;CTFshow上的新题，搞了一天&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://sh1k4ku.github.io/categories/CTF/"/>
    
    
    <category term="Crypto" scheme="http://sh1k4ku.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>lattice_learning</title>
    <link href="http://sh1k4ku.github.io/2021/07/27/lattice-learning/"/>
    <id>http://sh1k4ku.github.io/2021/07/27/lattice-learning/</id>
    <published>2021-07-27T08:51:43.000Z</published>
    <updated>2021-07-27T09:15:17.816Z</updated>
    
    <content type="html"><![CDATA[<p>有关格理论的学习记录。</p><span id="more"></span><h1 id="格的定义"><a href="#格的定义" class="headerlink" title="格的定义"></a>格的定义</h1><p>格的定义可以从向量空间引申出来：</p><pre><code>一组线性无关的的向量v1，v2，...，vn，它们的线性组合a1v1+a2v2+...+anvn可以表示一个空间，如果a1,a2，...，an全为整数，则生成了一个格L。则这组向量称为格的基，向量个数称为格的维数。</code></pre><h2 id="基础区域"><a href="#基础区域" class="headerlink" title="基础区域"></a>基础区域</h2><p>格的基础区域为即当a1，an，,,,，an为0或1组成的一个区域。格中任意一个向量可以由格的基础区域和唯一格外的一个向量表示。基础区域是格很重要的概念。</p><h2 id="格的行列式"><a href="#格的行列式" class="headerlink" title="格的行列式"></a>格的行列式</h2><p>格的行列式就是基础区域的n维体积，记作：</p><script type="math/tex; mode=display">det(L)</script><h2 id="基的转换"><a href="#基的转换" class="headerlink" title="基的转换"></a>基的转换</h2><p>设以v1，v2，…，vn为行向量构成的n阶矩阵为A，某一行列式等于1的n阶矩阵为    U，则矩阵B=UA中的行向量也是格L的一组基。<br>从<strong>线性变换</strong>的本质来看，线性变换是对空间进行伸缩或者翻转的操作（可惜大多数高校的非数学专业是不会讲这些的，具体可以看b站3b1b的搬运，有关线性代数的本质的介绍，可以给我们很直观的理解），由于U的行列式为1，那么变换后的基础区域体积不变。</p><h2 id="格的两大难题"><a href="#格的两大难题" class="headerlink" title="格的两大难题"></a>格的两大难题</h2><p>均为NP完全问题</p><h3 id="最短向量问题"><a href="#最短向量问题" class="headerlink" title="最短向量问题"></a>最短向量问题</h3><p>简称<strong>SVP</strong>，在格中寻找一个非零向量，使它的范数最小。</p><h3 id="最近向量问题"><a href="#最近向量问题" class="headerlink" title="最近向量问题"></a>最近向量问题</h3><p>简称<strong>CVP</strong>，给定一个不在格中的向量，找到格中一个向量使它最接近给定的向量，即欧几里得范数最小。</p><h1 id="重要定理"><a href="#重要定理" class="headerlink" title="重要定理"></a>重要定理</h1><h2 id="Hadamard不等式"><a href="#Hadamard不等式" class="headerlink" title="Hadamard不等式"></a>Hadamard不等式</h2><p>格L的基础区域为F，对于它任意一个基</p><script type="math/tex; mode=display">v_1,v_2,...,v_n</script><p>有：</p><script type="math/tex; mode=display">det(L)=vol(F)\leq||v_1||*||v_2||*...*||v_n||</script><p>基向量越接近正交，则上式越接近等式</p><h3 id="Hadamard比率"><a href="#Hadamard比率" class="headerlink" title="Hadamard比率"></a>Hadamard比率</h3><script type="math/tex; mode=display">H(L)=(\frac{det(L)}{||v_1||*||v_2||*...*||v_n||})^{1/n}</script><p>当这个值越接近1，则基越接近两两正交</p><h2 id="Hermite定理"><a href="#Hermite定理" class="headerlink" title="Hermite定理"></a>Hermite定理</h2><p>所有n维的格L都包含一个非0向量</p><script type="math/tex; mode=display">v\in L，满足||v||\leq\gamma_ndet(L)^{1/n}</script><p>对于给定的维度n</p><script type="math/tex; mode=display">Hermite常量\gamma_n是一个最小值，</script><p>它可以使所有n维格L都包含非零向量</p><script type="math/tex; mode=display">v\in L满足上式。</script><p>其中Hertmite常量</p><script type="math/tex; mode=display">\gamma_n满足：\frac{n}{2Πe}\leq\gamma_n\leq\frac{n}{Πe}</script><h2 id="Minkowski定理"><a href="#Minkowski定理" class="headerlink" title="Minkowski定理"></a>Minkowski定理</h2><script type="math/tex; mode=display">设L\subset R^n是一个n维的格，S\subset R^n是一个对称凸面集合，其体积满足：</script><script type="math/tex; mode=display">vol(S)>2^ndet(L)$</script><p>如果S满足封闭性，则上式等式成立。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有关格理论的学习记录。&lt;/p&gt;</summary>
    
    
    
    <category term="Lattice" scheme="http://sh1k4ku.github.io/categories/Lattice/"/>
    
    
    <category term="Lattice" scheme="http://sh1k4ku.github.io/tags/Lattice/"/>
    
    <category term="Crypto" scheme="http://sh1k4ku.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://sh1k4ku.github.io/2021/07/26/Test/"/>
    <id>http://sh1k4ku.github.io/2021/07/26/Test/</id>
    <published>2021-07-26T09:43:59.903Z</published>
    <updated>2021-08-12T02:55:02.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h1><p>I’m sh1k4ku</p><span id="more"></span><p>回忆前几个月，自4月进入401后，大大小小也打了不少比赛，大部分的题都是没有解出的，每次自己也会很自责，但似乎又无能为力。</p><p>一开始的习惯不好，没有在赛后即使复现，当时想着之后学到一定程度了自然会做了，导致进步缓慢。</p><p>不久前才意识到这是大错特错的，所以开了此blog，欲改变自己的懒惰，不要拖队里师傅们的后腿。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Hello-Hexo&quot;&gt;&lt;a href=&quot;#Hello-Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hello Hexo&quot;&gt;&lt;/a&gt;Hello Hexo&lt;/h1&gt;&lt;p&gt;I’m sh1k4ku&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="http://sh1k4ku.github.io/categories/hexo/"/>
    
    
    <category term="-hexo" scheme="http://sh1k4ku.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>SCUCTF</title>
    <link href="http://sh1k4ku.github.io/2021/06/04/6.4SCUCTF/"/>
    <id>http://sh1k4ku.github.io/2021/06/04/6.4SCUCTF/</id>
    <published>2021-06-04T07:40:24.000Z</published>
    <updated>2021-07-27T09:07:21.118Z</updated>
    
    <content type="html"><![CDATA[<p>用以前的的博客测试一下</p><span id="more"></span><h1 id="贝斯手"><a href="#贝斯手" class="headerlink" title="贝斯手"></a>贝斯手</h1><p>题目暗示了是base家族，先后使用base64 32 long_to_bytes 85和58解密即可获得flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base58</span><br><span class="line"></span><br><span class="line">cipher=<span class="string">&#x27;R1EzVElOQlRHSTNVSU5aVUdRNERNTlpWR0UyREVOS0dHWTJES01aVUlZMkRHTkJSR1JCVE9OUlhHNDNFSU5CWUdSRERNUUpXR00yVElOQlNHUTNUTU1aV0dBMkRPTkJSR1laVE9OSldHQTNES01SV0dZMkRLTVJXSU0zRE9OSlFHVTRETVJCVUdRWlVHTVpVR1VaVE9SQlhJUTJETz09PQ==&#x27;</span></span><br><span class="line"></span><br><span class="line">res=b64decode(cipher)</span><br><span class="line"></span><br><span class="line">res=b32decode(res)</span><br><span class="line"></span><br><span class="line">res=long_to_bytes(<span class="built_in">int</span>(res,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">res=b85decode(res)</span><br><span class="line"></span><br><span class="line">res=base58.b58decode(res)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>flag：scuctf{M4ny_k1nds_0f_13a5e!}</strong></p><h1 id="crypto1"><a href="#crypto1" class="headerlink" title="crypto1"></a>crypto1</h1><p>预测随机数，有现成的库可以用。要将312个64位数拆成624个32位数，因为32位输出顺序是<strong>abcd</strong>,而64位的顺序是<strong>badc</strong>，所以要反过来取，注意还要填充，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> RandCrack</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;./test&quot;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">rc=RandCrack()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">312</span>):</span><br><span class="line">    a=<span class="built_in">int</span>(f.readline())</span><br><span class="line">    a=<span class="built_in">bin</span>(a)[<span class="number">2</span>:].zfill(<span class="number">64</span>)</span><br><span class="line">    c=<span class="built_in">int</span>(<span class="string">&#x27;0b&#x27;</span>+a[:<span class="number">32</span>],<span class="number">2</span>)</span><br><span class="line">    b=<span class="built_in">int</span>(<span class="string">&#x27;0b&#x27;</span>+a[<span class="number">32</span>:],<span class="number">2</span>)</span><br><span class="line">    rc.submit(c)</span><br><span class="line">    rc.submit(b)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">res=rc.predict_getrandbits(<span class="number">128</span>)</span><br><span class="line">key1=(long_to_bytes(res))</span><br><span class="line"></span><br><span class="line">res=<span class="built_in">open</span>(<span class="string">&#x27;./out&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">aes = AES.new(key1, AES.MODE_CBC, <span class="string">b&quot;\x00&quot;</span>*<span class="number">16</span>)</span><br><span class="line">flag=aes1.decrypt(res)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>flag：scuctf{af0sd_f8}</strong></p><h1 id="crypto2"><a href="#crypto2" class="headerlink" title="crypto2"></a>crypto2</h1><p>简单的CopperSmith<br>p是512位的，x是128位，将x首元变为1，转化后p_是1019位的，未知低128位，那么用CopperSmith Method即可解决。得到的p再在模n下和2^ex相乘即可得到真正的p。附上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;sage</span></span><br><span class="line"><span class="string">n = 85016144249518040150910227120120655178858680112497903474795846550337648959184474608344455198424753002209821827392389091448043545937173891641586356377876821641241033232828279439195610943286663032638048058568003136520988549470764306016674503217880123290623177055115638997384030786304744623796469032887028528817</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c = 83724265903365973936178131138176403586796491037282811488797349096425411605088349291193550728134684573063610685342590513444340298881918101517014943046522979731970278182306111863948764449232289625176702192589838375986050458189860493609407060988207562417247647655585368569618561494059816502622854344519538215287</span></span><br><span class="line"><span class="string">pbar = 4450463823628350893648746241337847373556196959762621885713665365237037340874488165755826348254697529157574566792939002187459776672801308978738078688091668148118673194644809701286264701999481650571431714684293423463355990167658855533422964048092514208406515703766237697665676941598677911363439038209842058509</span></span><br><span class="line"><span class="string">kbits = 128</span></span><br><span class="line"><span class="string">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span></span><br><span class="line"><span class="string">f = x + pbar</span></span><br><span class="line"><span class="string">x0 = f.small_roots(X=2^kbits, beta=0.5)[0]  </span></span><br><span class="line"><span class="string">p = x0 + pbar</span></span><br><span class="line"><span class="string">print(p)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> nextprime</span><br><span class="line">leak=<span class="number">1145141920069</span></span><br><span class="line">n=   <span class="number">85016144249518040150910227120120655178858680112497903474795846550337648959184474608344455198424753002209821827392389091448043545937173891641586356377876821641241033232828279439195610943286663032638048058568003136520988549470764306016674503217880123290623177055115638997384030786304744623796469032887028528817</span></span><br><span class="line">c=   <span class="number">83724265903365973936178131138176403586796491037282811488797349096425411605088349291193550728134684573063610685342590513444340298881918101517014943046522979731970278182306111863948764449232289625176702192589838375986050458189860493609407060988207562417247647655585368569618561494059816502622854344519538215287</span></span><br><span class="line">pbar=<span class="number">4450463823628350893648746241337847373556196959762621885713665365237037340874488165755826348254697529157574566792939002187459776672801308978738078688091668148118673194644809701286264701999481650571431714684293423463355990167658855533422964048092514208406515703766237697665676941598677911363439038209842058509</span></span><br><span class="line">ex = <span class="number">384</span></span><br><span class="line">p_=<span class="number">4450463823628350893648746241337847373556196959762621885713665365237037340874488165755826348254697529157574566792939002187459776672801308978738078688091668148118673194644809701286264701999481650571431714684293423463355990167658855533422964048092514208406515703766237697896644308153471350247313227602240058029</span></span><br><span class="line">p=p_*<span class="number">2</span>**ex%n</span><br><span class="line">q=n//p</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(<span class="number">65537</span>,phi)</span><br><span class="line">m=gmpy2.powmod(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p><strong>flag:scuctf{f05fe93d159b398fe25f280d94241261}</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用以前的的博客测试一下&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://sh1k4ku.github.io/categories/CTF/"/>
    
    
    <category term="Crypto" scheme="http://sh1k4ku.github.io/tags/Crypto/"/>
    
  </entry>
  
</feed>
